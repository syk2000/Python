다중 상속
    여러 클래스를 동시에 상속 받을 수 있음

	    class <클래스 이름>(부모1, 부모2):
	        ....
    위와 같은 형태로 사용

    상속받은 클래스들의 변수와 메소드를 모두 사용 가능
    여러 클래스를 상속 받았을때, super()는 첫번째 부모만을 의미

    다른 부모의 메서드를 오버라이딩 하였을 때,
    부모의 메서드를 호출하고 싶으면

 	<부모 클래스 이름>.<메서드 이름>(self,..)

    와 같은 형태로 사용해야 함

    부모 클래스들에 같은 이름의 메서드가 있다면?
	첫번째 부모의 메서드가 호출됨

비공개 변수
    클래스 내부에서만 접근 가능한 변수
    파이썬엔 존재하지 않음. 대신에, _로 변수명/메서드명 이 시작하면
    비공개 변수처럼 취급해 주기로 약속

    약속일 뿐 이므로, 안지켜도 문법 오류는 아님

Name mangling
    부모 자식간 또는 상속받은 클래스간 이름이 겹칠 경우,
    클래스 내부에서 사용하는 메서드도 오버라이딩 되는 메서드를 사용
    따라서 내부 동작이 달라질 수 있음

    이 문제를 해결하기 위한 방법

    __(언더바 두개) 로 변수명/메서드명 이 시작하면, 
    name mangling이 동작

    이 경우 이름이 내부적으로, _classname__name 으로 변경됨
    클래스 내부에서는 __name 으로 호출 가능하지만,
    클래스 외부에서는 _classname__name 으로 호출하게 됨
	클래스 외부 는, 클래스의 인스턴스에서 호출시에도 의미함

    즉, 여러 클래스에서 같은 이름을 써도 오버라이딩 등 이슈가 없음

    마치 비공개 변수처럼 동작하게 됨! 하지만, 여전히 이름을 정확히 
    작성 시 접근 가능함을 잊으면 안됨
    
Name mangling 을 사용하여 어제 작성한 MaxLimit 의 
is_hund 를 사용하는 방식을 수정해 주세요


데이터 뭉치로 활용
    빈 클래스를 만들고, 값을 넣으면 데이터 뭉치로 활용 가능
	>>> class A:
		pass

	>>> test = A()
	>>> test.val = 54
	>>> test.name="dd"
	>>> test.val
	54
	>>> test.name
	'dd'

이터레이터 로 활용
    이터레이터 라는 것은? iterable한 객체
	it = iter(객체)	<= 객체의 이터레이터 리턴
	next(it)		<= 하나씩 출력
			<= 끝나면, StopIteration 에러 raise

    즉, iter 함수에 대응하는 메서드와, next함수에 대응하는 메서드가
    있는 객체

	iter 함수에 대응하는 메서드는 __iter__(self) 
		__next__ 메서드를 가진 객체를 돌려줘야 함
	next 함수에 대응하는 메서드는 __next__(self)
		값을 돌려주다가 특정 시점에 StopIteration raise

제너레이터
    함수를 활용해서 내부적으로 자동으로 이터레이터를 만들어줌
    반복문이 있는 함수에서, yield 를 사용할 경우, 
    자동으로 __iter__ 와 __next__ 가 내부적으로 만들어짐

    yield 뒤에 있는 값을 리턴하는 터레이터가 됨
	def reverse(data):
	    for i in range(len(data)-1, -1, -1):
	        yield data[i]
    
	>>> for i in reverse("hello"):
		print(i)
	o
	l
	l
	e
	h        

리스트 컴프리헨션
    반복문을 한줄로 작성하면, 리스트로 변환됨
    	ex)
	[i*i for i in range(10)]
    람다와 문법이 유사하며, 안에서 if문 사용을 통해 filter도 가능
    이 때, if문은 for문 오른쪽에 위치해야 함
	ex)
	[x for x in range(10) if x % 2 == 0]

    람다와 같이, if문이 for문 왼쪽에 있을때, 조건식도 가능
	>>> [0 if x<5 else x for x in range(10)]
	[0, 0, 0, 0, 0, 5, 6, 7, 8, 9]

    for문과 if문 반복이 가능하며,
    for문은 왼쪽 for문 부터 수행됨

[(x,y) for x in range(1,10,1) for y in range(10,1, -1) if x>5 if y>5 ]
[(6, 10), (6, 9), (6, 8), (6, 7), (6, 6), (7, 10), (7, 9), (7, 8), (7, 7), (7, 6), (8, 10), (8, 9), (8, 8), (8, 7), (8, 6), (9, 10), (9, 9), (9, 8), (9, 7), (9, 6)]

    딕셔너리 라면?
	{x:0 for x in range(10)}
    위와 같이 딕셔너리 형태에 맞게 작성시엔 딕셔너리가 됨
    역시, if문 사용 가능

set (집합)
    수학에서 말하는 집합
    중괄호로 선언하되, 딕셔너리와 달리. : 를 사용하지 않고 
    , 로 값을 열거

    빈 집합은, a = set() 과 같이 선언하여야 함. 
    a = {} 로 선언시 딕셔너리가 됨

    add(n)		값 추가
    remove(n)	값 제거
    pop()		값을 제거하고 출력 
    (마지막에 위치한 값을 제거하지만, 정렬이 일정하지 않으므로 
     무엇이 제거 될 지 알기 어려움)

    합집합 a.union(b)
    교집합 a.intersection(b)
    차집합 a - b
    
    부분집합 a.issubset(b) a가 b의 부분집합인지 확인
    상위집합 a.issuperset(b) a가 b의 슈퍼셋 인지 확인
